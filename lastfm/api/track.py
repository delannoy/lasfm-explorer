#!/usr/bin/env python3

import uuid

import typ
import auth
import param
import request
import secret

import pydantic

@param.required
@pydantic.validate_arguments
def addTags(method: str, api_key: typ.UUID, artist: str, track: str, tags: typ.tags, api_sig: typ.UUID = None, sk: str = secret.sk) -> typ.response:
    '''Tag an album using a list of user supplied tags.
        artist  : Required : The artist name
        track   : Required : The track name
        tags    : Required : A comma delimited list of user supplied tags to apply to this track. Accepts a maximum of 10 tags.
        api_sig : Required : A Last.fm method signature. See authentication for more information.
        sk      : Required : A session key generated by authenticating a user via the authentication protocol.
        api_key : Required : A Last.fm API key.
    '''
    tags = param.listToCSV(tags)
    api_sig = auth.calculate_api_sig(param.params(locals()))
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def getCorrection(method: str, api_key: typ.UUID, artist: str, track: str) -> typ.response:
    '''Use the last.fm corrections data to check whether the supplied track has a correction to a canonical track
        artist  : Required : The artist name to correct.
        track   : Required : The track name to correct.
        api_key : Required : A Last.fm API key.
    '''
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def getInfo(method: str, api_key: typ.UUID, artist: str = None, track: str = None, mbid: uuid.UUID = None, user: str = secret.user, autocorrect: int = 0) -> typ.response:
    '''Get the metadata for a track on Last.fm using the artist/track name or a musicbrainz id.
        artist      : Required [unless mbid] : The artist name
        track       : Required [unless mbid] : The track name
        mbid        : Optional               : The musicbrainz id for the track
        username    : Optional               : The username for the context of the request. If supplied, the user's playcount for this track and whether they have loved the track is included in the response.
        autocorrect : Optional               : Transform misspelled artist and track names into correct artist and track names, returning the correct version instead. The corrected artist and track name will be returned in the response. [0|1]
        api_key     : Required               : A Last.fm API key.
    '''
    assert (artist and track) or mbid, '`artist` and `track` must be provided unless `mbid` is specified'
    autocorrect = int(autocorrect)
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def getSimilar(method: str, api_key: typ.UUID, artist: str = None, track: str = None, mbid: uuid.UUID = None, autocorrect: int = 0, limit: int = 100) -> typ.response:
    '''Get the similar tracks for this track on Last.fm, based on listening data.
        track       : Required [unless mbid] : The track name
        artist      : Required [unless mbid] : The artist name
        mbid        : Optional               : The musicbrainz id for the track
        autocorrect : Optional               : Transform misspelled artist and track names into correct artist and track names, returning the correct version instead. The corrected artist and track name will be returned in the response. [0|1]
        limit       : Optional               : Maximum number of similar tracks to return
        api_key     : Required               : A Last.fm API key.
    '''
    assert (artist and track) or mbid, '`artist` and `track` must be provided unless `mbid` is specified'
    autocorrect = int(autocorrect)
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def getTags(method: str, api_key: typ.UUID, artist: str = None, track: str = None, mbid: uuid.UUID = None, user: str = secret.user, autocorrect: int = 0) -> typ.response:
    '''Get the tags applied by an individual user to a track on Last.fm. To retrieve the list of top tags applied to a track by all users use track.getTopTags.
        artist      : Required [unless mbid] : The artist name
        track       : Required [unless mbid] : The track name
        mbid        : Optional               : The musicbrainz id for the track
        user        : Optional               : If called in non-authenticated mode you must specify the user to look up
        autocorrect : Optional               : Transform misspelled artist and track names into correct artist and track names, returning the correct version instead. The corrected artist and track name will be returned in the response. [0|1]
        api_key     : Required               : A Last.fm API key.
    '''
    assert (artist and track) or mbid, '`artist` and `track` must be provided unless `mbid` is specified'
    autocorrect = int(autocorrect)
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def getTopTags(method: str, api_key: typ.UUID, artist: str = None, track: str = None, mbid: uuid.UUID = None, autocorrect: int = 0) -> typ.response:
    '''Get the top tags for this track on Last.fm, ordered by tag count. Supply either track & artist name or mbid.
        artist      : Required [unless mbid] : The artist name
        track       : Required [unless mbid] : The track name
        mbid        : Optional               : The musicbrainz id for the track
        autocorrect : Optional               : Transform misspelled artist and track names into correct artist and track names, returning the correct version instead. The corrected artist and track name will be returned in the response. [0|1]
        api_key     : Required               : A Last.fm API key.
    '''
    assert (artist and track) or mbid, '`artist` and `track` must be provided unless `mbid` is specified'
    autocorrect = int(autocorrect)
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def love(method: str, api_key: typ.UUID, artist: str, track: str, api_sig: typ.UUID = None, sk: str = secret.sk) -> typ.response:
    '''Love a track for a user profile.
        artist  : Required : An artist name (utf8 encoded)
        track   : Required : A track name (utf8 encoded)
        api_sig : Required : A Last.fm method signature. See authentication for more information.
        sk      : Required : A session key generated by authenticating a user via the authentication protocol.
        api_key : Required : A Last.fm API key.
    '''
    api_sig = auth.calculate_api_sig(param.params(locals()))
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def removeTag(method: str, api_key: typ.UUID, artist: str, track: str, tag: str, api_sig: typ.UUID = None, sk: str = secret.sk) -> typ.response:
    '''Remove a user's tag from a track.
        artist  : Required : The artist name
        track   : Required : The track name
        tag     : Required : A single user tag to remove from this track.
        api_sig : Required : A Last.fm method signature. See authentication for more information.
        sk      : Required : A session key generated by authenticating a user via the authentication protocol.
        api_key : Required : A Last.fm API key.
    '''
    api_sig = auth.calculate_api_sig(param.params(locals()))
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def scrobble(method: str, api_key: typ.UUID, artist: typ.artist, track: typ.track, timestamp: typ.timestamp, album: typ.album, mbid: typ.mbid = None, trackNumber: typ.trackNumber = None, albumArtist: typ.albumArtist = None, duration: typ.duration = None, context: typ.context = None, streamId: typ.streamId = None, chosenByUser: typ.chosenByUser = None, api_sig: typ.UUID = None, sk: str = secret.sk) -> typ.response:
    '''Used to add a track-play to a user's profile. Scrobble a track, or a batch of tracks. Tracks are passed to the service using array notation for each of the below params, up to a maximum of 50 scrobbles per batch [0<=i<=49]. If you are only sending a single scrobble the array notation may be ommited. Note: Extra care should be taken while calculating the signature when using array notation as the parameter names MUST be sorted according to the ASCII table (i.e., artist[10] comes before artist[1]). It is important to not use the corrections returned by the now playing service as input for the scrobble request, unless they have been explicitly approved by the user. Parameter names are case sensitive.
        artist[i]       : Required : The artist name.
        track[i]        : Required : The track name.
        timestamp[i]    : Required : The time the track started playing, in UNIX timestamp format (integer number of seconds since 00:00:00, January 1st 1970 UTC). This must be in the UTC time zone.
        album[i]        : Optional : The album name.
        mbid[i]         : Optional : The MusicBrainz Track ID.
        trackNumber[i]  : Optional : The track number of the track on the album.
        albumArtist[i]  : Optional : The album artist - if this differs from the track artist.
        duration[i]     : Optional : The length of the track in seconds.
        context[i]      : Optional : Sub-client version (not public, only enabled for certain API keys)
        streamId[i]     : Optional : The stream id for this track received from the radio.getPlaylist service, if scrobbling Last.fm radio
        chosenByUser[i] : Optional : Set to 1 if the user chose this song, or 0 if the song was chosen by someone else (such as a radio station or recommendation service). Assumes 1 if not specified
        api_sig         : Required : A Last.fm method signature. See authentication for more information.
        sk              : Required : A session key generated by authenticating a user via the authentication protocol.
        api_key         : Required : A Last.fm API key.
    '''
    params = param.params(locals())
    arrayFields = ('artist', 'track', 'timestamp', 'album', 'mbid', 'trackNumber', 'albumArtist', 'duration', 'context', 'streamId')
    params = {**params, **param.arrayParams({k:v for k, v in params.items() if k in arrayFields})}
    _ = [params.pop(key, None) for key in arrayFields]
    params.update({"api_sig": auth.calculate_api_sig(params)})
    return request.get(url=param.url, headers=param.headers, params=param.params(params))

@param.required
@pydantic.validate_arguments
def search(method: str, api_key: typ.UUID, track: str, artist: str = None, limit: int = 30, page: int = 1) -> typ.response:
    '''Search for a track by track name. Returns track matches sorted by relevance.
        track   : Required : The track name
        artist  : Optional : Narrow your search by specifying an artist.
        limit   : Optional : The number of results to fetch per page. Defaults to 30.
        page    : Optional : The page number to fetch. Defaults to first page.
        api_key : Required : A Last.fm API key.
    '''
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def unlove(method: str, api_key: typ.UUID, artist: str, track: str, api_sig: typ.UUID = None, sk: str = secret.sk) -> typ.response:
    '''UnLove a track for a user profile.
        artist  : Required : An artist name (utf8 encoded)
        track   : Required : A track name (utf8 encoded)
        api_sig : Required : A Last.fm method signature. See authentication for more information.
        sk      : Required : A session key generated by authenticating a user via the authentication protocol.
        api_key : Required : A Last.fm API key.
    '''
    api_sig = auth.calculate_api_sig(param.params(locals()))
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))

@param.required
@pydantic.validate_arguments
def updateNowPlaying(method: str, api_key: typ.UUID, artist: str, track: str, album: str = None, trackNumber: int = None, mbid: typ.UUID = None, duration: int = None, albumArtist: str = None, context: str = None, api_sig: typ.UUID = None, sk: str = secret.sk) -> typ.response:
    '''Used to notify Last.fm that a user has started listening to a track. Parameter names are case sensitive.
        artist      : Required : The artist name.
        track       : Required : The track name.
        album       : Optional : The album name.
        trackNumber : Optional : The track number of the track on the album.
        mbid        : Optional : The MusicBrainz Track ID.
        duration    : Optional : The length of the track in seconds.
        albumArtist : Optional : The album artist - if this differs from the track artist.
        context     : Optional : Sub-client version (not public, only enabled for certain API keys)
        api_sig     : Required : A Last.fm method signature. See authentication for more information.
        sk          : Required : A session key generated by authenticating a user via the authentication protocol.
        api_key     : Required : A Last.fm API key.
    '''
    api_sig = auth.calculate_api_sig(param.params(locals()))
    return request.get(url=param.url, headers=param.headers, params=param.params(locals()))
